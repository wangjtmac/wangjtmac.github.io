import{_ as t,c as a,o,ag as r}from"./chunks/framework.D7tYYb9F.js";const h=JSON.parse('{"title":"Vue3 响应式系统原理解析","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue3/reactivity-principle.md","filePath":"vue/vue3/reactivity-principle.md","lastUpdated":1751328890000}'),l={name:"vue/vue3/reactivity-principle.md"};function i(d,e,c,n,s,p){return o(),a("div",null,e[0]||(e[0]=[r(`<h1 id="vue3-响应式系统原理解析" tabindex="-1">Vue3 响应式系统原理解析 <a class="header-anchor" href="#vue3-响应式系统原理解析" aria-label="Permalink to &quot;Vue3 响应式系统原理解析&quot;">​</a></h1><p>Vue3 响应式系统是其核心功能之一，它基于 ES6 的 Proxy 实现。这篇文档将深入解析 Vue3 响应式系统的工作原理，帮助你更好地理解 Vue3。</p><h2 id="响应式系统的核心概念" tabindex="-1">响应式系统的核心概念 <a class="header-anchor" href="#响应式系统的核心概念" aria-label="Permalink to &quot;响应式系统的核心概念&quot;">​</a></h2><p>Vue3 的响应式系统主要由以下几个核心概念组成：</p><ol><li><strong>响应式对象（Reactive Objects）</strong>：通过 <code>reactive()</code> 函数创建的对象，其属性的访问和修改都会被追踪。</li><li><strong>引用（Refs）</strong>：通过 <code>ref()</code> 函数创建的响应式引用，特别适用于原始类型值。</li><li><strong>副作用（Effects）</strong>：响应式状态变化时需要执行的函数，如组件更新、计算属性重新计算等。</li><li><strong>依赖追踪（Dependency Tracking）</strong>：系统自动收集和管理副作用函数与响应式状态之间的依赖关系。</li></ol><h2 id="响应式系统的数据结构" tabindex="-1">响应式系统的数据结构 <a class="header-anchor" href="#响应式系统的数据结构" aria-label="Permalink to &quot;响应式系统的数据结构&quot;">​</a></h2><p>Vue3 响应式系统的核心数据结构如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>targetMap: WeakMap(target -&gt; depsMap)</span></span>
<span class="line"><span>depsMap: Map(key -&gt; dep)</span></span>
<span class="line"><span>dep: Set(effect)</span></span></code></pre></div><ul><li><strong>targetMap</strong>：一个 WeakMap，键是响应式对象，值是该对象的依赖映射（depsMap）。</li><li><strong>depsMap</strong>：一个 Map，键是对象的属性名，值是依赖该属性的副作用函数集合（dep）。</li><li><strong>dep</strong>：一个 Set，包含依赖于特定属性的所有副作用函数。</li></ul><h2 id="proxy-与拦截器" tabindex="-1">Proxy 与拦截器 <a class="header-anchor" href="#proxy-与拦截器" aria-label="Permalink to &quot;Proxy 与拦截器&quot;">​</a></h2><p>Vue3 使用 Proxy 来拦截对象的操作。以下是主要的拦截器：</p><h3 id="get-拦截器" tabindex="-1">get 拦截器 <a class="header-anchor" href="#get-拦截器" aria-label="Permalink to &quot;get 拦截器&quot;">​</a></h3><p>当访问响应式对象的属性时，<code>get</code> 拦截器会：</p><ol><li>如果当前有活跃的副作用函数，则将其添加到该属性的依赖集合中（<strong>依赖收集</strong>）。</li><li>如果属性值是对象，则递归地将其转换为响应式对象（<strong>深层响应式</strong>）。</li><li>返回属性值。</li></ol><h3 id="set-拦截器" tabindex="-1">set 拦截器 <a class="header-anchor" href="#set-拦截器" aria-label="Permalink to &quot;set 拦截器&quot;">​</a></h3><p>当修改响应式对象的属性时，<code>set</code> 拦截器会：</p><ol><li>设置新的属性值。</li><li>如果值发生了变化，则通知所有依赖该属性的副作用函数重新执行（<strong>派发更新</strong>）。</li></ol><h2 id="effect-函数的原理" tabindex="-1">effect 函数的原理 <a class="header-anchor" href="#effect-函数的原理" aria-label="Permalink to &quot;effect 函数的原理&quot;">​</a></h2><p><code>effect</code> 函数是响应式系统的核心，它负责创建并执行副作用函数。主要工作流程如下：</p><ol><li>创建一个副作用函数包装器（effectFn）。</li><li>设置 <code>activeEffect</code> 为当前副作用函数。</li><li>执行原始函数，在执行过程中会访问响应式对象的属性，触发 <code>get</code> 拦截器进行依赖收集。</li><li>恢复 <code>activeEffect</code> 的值。</li><li>如果响应式对象的属性发生变化，通过之前收集的依赖关系找到并重新执行对应的副作用函数。</li></ol><h2 id="嵌套-effect-的处理" tabindex="-1">嵌套 effect 的处理 <a class="header-anchor" href="#嵌套-effect-的处理" aria-label="Permalink to &quot;嵌套 effect 的处理&quot;">​</a></h2><p>Vue3 使用一个栈（effectStack）来处理嵌套的副作用函数。当一个副作用函数执行时：</p><ol><li>将其推入 effectStack。</li><li>设置 activeEffect 为当前副作用函数。</li><li>副作用函数执行完毕后，将其从 effectStack 弹出。</li><li>恢复 activeEffect 为栈顶的副作用函数（如果有的话）。</li></ol><p>这确保了在嵌套场景下，依赖收集始终与正确的副作用函数关联。</p><h2 id="ref-的实现原理" tabindex="-1">ref 的实现原理 <a class="header-anchor" href="#ref-的实现原理" aria-label="Permalink to &quot;ref 的实现原理&quot;">​</a></h2><p><code>ref</code> 是一个带有 <code>.value</code> 属性的对象，其内部使用了 getter 和 setter：</p><ul><li><strong>getter</strong>：访问 <code>.value</code> 时，会追踪依赖。</li><li><strong>setter</strong>：修改 <code>.value</code> 时，如果值发生变化，会触发依赖更新。</li></ul><p>虽然实现方式不同，但 <code>ref</code> 与 <code>reactive</code> 共享相同的依赖追踪系统，确保了一致的响应式行为。</p><h2 id="computed-的实现原理" tabindex="-1">computed 的实现原理 <a class="header-anchor" href="#computed-的实现原理" aria-label="Permalink to &quot;computed 的实现原理&quot;">​</a></h2><p>计算属性本质上是一个特殊的 <code>ref</code>，具有以下特点：</p><ol><li><strong>延迟计算</strong>：只有在访问其 <code>.value</code> 时才会计算。</li><li><strong>缓存</strong>：计算结果会被缓存，只有当依赖变化时才会重新计算。</li><li><strong>依赖追踪</strong>：自动收集其依赖项，并在依赖变化时标记为需要重新计算。</li></ol><p>计算属性使用一个 <code>dirty</code> 标志来判断是否需要重新计算，以及一个调度器来处理依赖变化时的行为。</p><h2 id="vue3-响应式系统的优势" tabindex="-1">Vue3 响应式系统的优势 <a class="header-anchor" href="#vue3-响应式系统的优势" aria-label="Permalink to &quot;Vue3 响应式系统的优势&quot;">​</a></h2><p>相比 Vue2 的 Object.defineProperty 实现，Vue3 的 Proxy 实现有以下优势：</p><ol><li><strong>全面拦截</strong>：可以拦截更多类型的属性操作，如删除属性、新增属性等。</li><li><strong>性能优化</strong>：避免了 Vue2 中的初始化递归遍历，初始化更快。</li><li><strong>集合类型支持</strong>：可以响应式地处理 Map、Set 等集合类型。</li><li><strong>更好的数组支持</strong>：直接支持通过索引修改数组元素和修改数组长度。</li></ol><h2 id="响应式系统的局限性" tabindex="-1">响应式系统的局限性 <a class="header-anchor" href="#响应式系统的局限性" aria-label="Permalink to &quot;响应式系统的局限性&quot;">​</a></h2><p>尽管 Vue3 的响应式系统功能强大，但也有一些局限性需要注意：</p><ol><li><strong>无法拦截属性删除</strong>：使用 <code>delete obj.prop</code> 不会触发响应式更新，应使用 <code>Vue.delete</code> 或解构赋值。</li><li><strong>新属性添加</strong>：对于已经创建的响应式对象，直接添加新属性不会自动成为响应式的，应使用 <code>Vue.set</code> 或新的重新赋值对象。</li><li><strong>原始类型限制</strong>：<code>reactive</code> 不能直接用于原始类型（如 string, number），这就是为什么需要 <code>ref</code>。</li></ol><h2 id="与-vue2-响应式系统的对比" tabindex="-1">与 Vue2 响应式系统的对比 <a class="header-anchor" href="#与-vue2-响应式系统的对比" aria-label="Permalink to &quot;与 Vue2 响应式系统的对比&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td>实现方式</td><td>Object.defineProperty</td><td>Proxy</td></tr><tr><td>深度响应</td><td>初始化时递归定义</td><td>访问时延迟定义</td></tr><tr><td>数组处理</td><td>特殊处理方法（如 push, pop）</td><td>直接支持所有操作</td></tr><tr><td>新增属性</td><td>需要 Vue.set</td><td>直接支持</td></tr><tr><td>删除属性</td><td>需要 Vue.delete</td><td>直接支持</td></tr><tr><td>集合支持</td><td>不支持</td><td>支持</td></tr><tr><td>性能</td><td>初始化较慢，运行时较快</td><td>初始化较快，运行时性能优</td></tr></tbody></table><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Vue3 的响应式系统是其最强大和创新的特性之一。它通过精确的依赖追踪和自动更新，使开发者可以声明式地处理状态变化，而无需手动保持视图和状态的同步。理解其工作原理不仅有助于更好地使用 Vue3，还能帮助我们在实际开发中避免常见的陷阱。</p><p>通过本文的学习，我们已经深入了解了 Vue3 响应式系统的核心概念、原理和实现细节，为进一步学习和使用 Vue3 奠定了坚实的基础。</p>`,43)]))}const f=t(l,[["render",i]]);export{h as __pageData,f as default};

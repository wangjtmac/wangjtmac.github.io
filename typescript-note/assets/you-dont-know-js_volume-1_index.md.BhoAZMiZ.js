import{_ as e,c as t,o as l,ag as i}from"./chunks/framework.C6BsaGkr.js";const u=JSON.parse('{"title":"第一卷（上卷）","description":"","frontmatter":{},"headers":[],"relativePath":"you-dont-know-js/volume-1/index.md","filePath":"you-dont-know-js/volume-1/index.md","lastUpdated":1755504345000}'),o={name:"you-dont-know-js/volume-1/index.md"};function r(s,a,n,h,d,c){return l(),t("div",null,a[0]||(a[0]=[i('<h1 id="第一卷-上卷" tabindex="-1">第一卷（上卷） <a class="header-anchor" href="#第一卷-上卷" aria-label="Permalink to &quot;第一卷（上卷）&quot;">​</a></h1><p>本卷聚焦两大核心主题：</p><ul><li>作用域与闭包（Scope &amp; Closures）</li><li>this 与对象原型（this &amp; Object Prototypes）</li></ul><p>目标：夯实 JS 运行时模型的底层理解，为类型系统与框架实践打下坚实基础。</p><h2 id="学习路径" tabindex="-1">学习路径 <a class="header-anchor" href="#学习路径" aria-label="Permalink to &quot;学习路径&quot;">​</a></h2><ul><li>先读：作用域与闭包（变量解析、词法环境、闭包本质）</li><li>再读：this 与对象原型（调用位置与绑定规则、原型链与委托）</li><li>最后：将概念映射到 TypeScript（类型层面与值层面的区别）</li></ul><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to &quot;目录&quot;">​</a></h2><ul><li><a href="./scope-closures.html">作用域和闭包</a></li><li><a href="./this-object-prototypes.html">this 和对象原型</a></li></ul><h2 id="推荐关注的能力" tabindex="-1">推荐关注的能力 <a class="header-anchor" href="#推荐关注的能力" aria-label="Permalink to &quot;推荐关注的能力&quot;">​</a></h2><ul><li>用“编译阶段 + 运行阶段”的视角拆解作用域</li><li>能够从“调用位置”准确推导 this 绑定</li><li>基于原型委托而非“类继承”的思考方式</li></ul><h2 id="延伸到-typescript-的思考" tabindex="-1">延伸到 TypeScript 的思考 <a class="header-anchor" href="#延伸到-typescript-的思考" aria-label="Permalink to &quot;延伸到 TypeScript 的思考&quot;">​</a></h2><ul><li>作用域/闭包是值层面机制，类型不会改变闭包行为</li><li>TS 的类只是语法糖，运行时仍是原型委托</li><li>在 TS 中区分：类型设计（编译时） vs 行为实现（运行时）</li></ul>',12)]))}const m=e(o,[["render",r]]);export{u as __pageData,m as default};

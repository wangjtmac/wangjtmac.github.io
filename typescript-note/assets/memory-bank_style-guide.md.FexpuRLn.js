import{_ as s,c as a,o as l,ag as n}from"./chunks/framework.C6BsaGkr.js";const c=JSON.parse('{"title":"TypeScript 研究项目 - 样式指南","description":"","frontmatter":{},"headers":[],"relativePath":"memory-bank/style-guide.md","filePath":"memory-bank/style-guide.md","lastUpdated":1752020944000}'),e={name:"memory-bank/style-guide.md"};function t(h,i,p,k,r,d){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="typescript-研究项目-样式指南" tabindex="-1">TypeScript 研究项目 - 样式指南 <a class="header-anchor" href="#typescript-研究项目-样式指南" aria-label="Permalink to &quot;TypeScript 研究项目 - 样式指南&quot;">​</a></h1><h2 id="代码风格" tabindex="-1">代码风格 <a class="header-anchor" href="#代码风格" aria-label="Permalink to &quot;代码风格&quot;">​</a></h2><h3 id="命名约定" tabindex="-1">命名约定 <a class="header-anchor" href="#命名约定" aria-label="Permalink to &quot;命名约定&quot;">​</a></h3><ul><li><strong>变量和函数</strong>: 使用驼峰命名法 (camelCase)</li><li><strong>类和接口</strong>: 使用帕斯卡命名法 (PascalCase)</li><li><strong>类型别名</strong>: 使用帕斯卡命名法 (PascalCase)</li><li><strong>泛型参数</strong>: 使用单个大写字母或帕斯卡命名法 (T, U, V 或 TValue, TKey)</li><li><strong>常量</strong>: 使用全大写下划线命名法 (UPPER_SNAKE_CASE)</li><li><strong>私有属性</strong>: 使用下划线前缀 (_privateProperty)</li><li><strong>文件名</strong>: 使用短横线命名法 (kebab-case.ts)</li></ul><h3 id="缩进和格式" tabindex="-1">缩进和格式 <a class="header-anchor" href="#缩进和格式" aria-label="Permalink to &quot;缩进和格式&quot;">​</a></h3><ul><li>使用 2 个空格进行缩进</li><li>每行最大长度为 80 个字符</li><li>使用单引号 (&#39;) 作为字符串默认引号</li><li>语句末尾使用分号 (😉</li><li>大括号始终使用 K&amp;R 风格 (在同一行开始)</li><li>逗号后面添加空格，逗号前不加空格</li></ul><h3 id="类型注解" tabindex="-1">类型注解 <a class="header-anchor" href="#类型注解" aria-label="Permalink to &quot;类型注解&quot;">​</a></h3><ul><li>优先使用类型推断，仅在必要时添加显式类型注解</li><li>函数参数和返回值应始终有类型注解</li><li>公共 API 和导出项应有完整的类型注解</li><li>复杂类型使用类型别名或接口进行命名</li><li>避免使用 <code>any</code> 类型，优先使用 <code>unknown</code></li><li>使用 <code>readonly</code> 标记不可变属性</li></ul><h2 id="文档风格" tabindex="-1">文档风格 <a class="header-anchor" href="#文档风格" aria-label="Permalink to &quot;文档风格&quot;">​</a></h2><h3 id="jsdoc-注释" tabindex="-1">JSDoc 注释 <a class="header-anchor" href="#jsdoc-注释" aria-label="Permalink to &quot;JSDoc 注释&quot;">​</a></h3><ul><li>所有导出的函数、类、接口和类型应有 JSDoc 注释</li><li>使用 <code>@param</code>, <code>@returns</code>, <code>@throws</code> 等标签说明函数行为</li><li>示例代码使用 <code>@example</code> 标签</li><li>复杂类型参数使用 <code>@template</code> 标签说明</li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 将数组转换为指定类型的映射对象</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 数组元素类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> K</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 对象键类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {T[]}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 源数组</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {(item: T) =&gt; K}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keyFn</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 键提取函数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@returns</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {Record&lt;K &amp; PropertyKey, T&gt;}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 映射对象</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@example</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * const users = [{ id: 1, name: &#39;Alice&#39; }, { id: 2, name: &#39;Bob&#39; }];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * const userMap = arrayToMap(users, user =&gt; user.id);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 结果: { 1: { id: 1, name: &#39;Alice&#39; }, 2: { id: 2, name: &#39;Bob&#39; } }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrayToMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PropertyKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  keyFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> K</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Record</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 实现...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="markdown-文档" tabindex="-1">Markdown 文档 <a class="header-anchor" href="#markdown-文档" aria-label="Permalink to &quot;Markdown 文档&quot;">​</a></h3><ul><li>使用标题层次结构组织内容</li><li>代码示例使用语法高亮</li><li>使用表格比较不同概念</li><li>重要概念使用加粗或斜体强调</li><li>使用列表组织相关项</li><li>添加链接指向相关资源</li></ul><h2 id="项目组织" tabindex="-1">项目组织 <a class="header-anchor" href="#项目组织" aria-label="Permalink to &quot;项目组织&quot;">​</a></h2><h3 id="目录结构" tabindex="-1">目录结构 <a class="header-anchor" href="#目录结构" aria-label="Permalink to &quot;目录结构&quot;">​</a></h3><ul><li><code>src/</code>: 源代码目录</li><li><code>examples/</code>: 示例代码目录</li><li><code>docs/</code>: 文档目录</li><li><code>tests/</code>: 测试目录</li></ul><h3 id="模块组织" tabindex="-1">模块组织 <a class="header-anchor" href="#模块组织" aria-label="Permalink to &quot;模块组织&quot;">​</a></h3><ul><li>相关功能组织在同一模块中</li><li>一个文件应该只有一个主要导出</li><li>类型定义可以单独放在 <code>.types.ts</code> 文件中</li><li>工具函数按功能领域组织</li></ul><h3 id="导入顺序" tabindex="-1">导入顺序 <a class="header-anchor" href="#导入顺序" aria-label="Permalink to &quot;导入顺序&quot;">​</a></h3><ol><li>外部库导入</li><li>项目内绝对路径导入</li><li>项目内相对路径导入</li><li>类型导入</li></ol><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 外部库</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useState, useEffect } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 项目绝对路径</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { config } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@/config&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 项目相对路径</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { formatDate } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;../utils/date&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 类型导入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { User, UserRole } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./types&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to &quot;最佳实践&quot;">​</a></h2><h3 id="类型安全" tabindex="-1">类型安全 <a class="header-anchor" href="#类型安全" aria-label="Permalink to &quot;类型安全&quot;">​</a></h3><ul><li>启用严格模式 (<code>strict: true</code>)</li><li>避免类型断言，优先使用类型守卫</li><li>使用可辨识联合类型而非枚举</li><li>优先使用 <code>unknown</code> 而非 <code>any</code></li><li>使用泛型增强函数和组件的复用性</li></ul><h3 id="函数设计" tabindex="-1">函数设计 <a class="header-anchor" href="#函数设计" aria-label="Permalink to &quot;函数设计&quot;">​</a></h3><ul><li>函数应该是纯函数</li><li>参数数量控制在 3 个以内</li><li>使用对象参数处理多参数情况</li><li>返回类型明确且一致</li><li>错误处理策略一致 (抛出错误或返回 Result 类型)</li></ul><h3 id="异步处理" tabindex="-1">异步处理 <a class="header-anchor" href="#异步处理" aria-label="Permalink to &quot;异步处理&quot;">​</a></h3><ul><li>使用 async/await 而非直接使用 Promise 链</li><li>统一错误处理模式</li><li>避免嵌套 Promise</li><li>使用 Promise.all 处理并行操作</li></ul><h3 id="不可变性" tabindex="-1">不可变性 <a class="header-anchor" href="#不可变性" aria-label="Permalink to &quot;不可变性&quot;">​</a></h3><ul><li>使用 <code>readonly</code> 修饰符</li><li>使用展开运算符创建新对象而非修改现有对象</li><li>使用不可变数据结构库 (如 Immutable.js) 处理复杂状态</li></ul>`,31)]))}const y=s(e,[["render",t]]);export{c as __pageData,y as default};

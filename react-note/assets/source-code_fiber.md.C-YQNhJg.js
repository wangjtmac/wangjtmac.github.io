import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.4lVnIIy3.js";const o=JSON.parse('{"title":"React Fiber 架构详解","description":"","frontmatter":{},"headers":[],"relativePath":"source-code/fiber.md","filePath":"source-code/fiber.md"}'),e={name:"source-code/fiber.md"};function t(p,s,h,r,k,E){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="react-fiber-架构详解" tabindex="-1">React Fiber 架构详解 <a class="header-anchor" href="#react-fiber-架构详解" aria-label="Permalink to &quot;React Fiber 架构详解&quot;">​</a></h1><p>Fiber 架构是 React 16 中引入的一种新的调和引擎实现，它的主要目标是提高 React 应用在动画、布局和手势等领域的响应能力。</p><h2 id="fiber-的背景与动机" tabindex="-1">Fiber 的背景与动机 <a class="header-anchor" href="#fiber-的背景与动机" aria-label="Permalink to &quot;Fiber 的背景与动机&quot;">​</a></h2><p>在 React 15 及之前的版本中，React 使用的是递归模型进行调和过程，这种模型被称为&quot;栈调和器&quot;（Stack Reconciler）。栈调和器有一个严重的限制：一旦开始渲染，就无法中断，直到整个组件树都完成渲染。这在处理大型组件树时可能导致主线程长时间被占用，从而阻塞用户交互和动画等高优先级任务。</p><p>Fiber 架构的设计目标是：</p><ol><li><strong>能够将渲染工作分割成多个块</strong>：不再一次性完成整个组件树的渲染。</li><li><strong>能够为不同类型的更新分配优先级</strong>：如动画更新可以优先于数据更新。</li><li><strong>能够暂停、中止或重用渲染工作</strong>：根据系统资源和用户交互情况调整渲染策略。</li><li><strong>能够在父子组件之间更灵活地切换</strong>：不再局限于递归模型。</li></ol><h2 id="fiber-的基本概念" tabindex="-1">Fiber 的基本概念 <a class="header-anchor" href="#fiber-的基本概念" aria-label="Permalink to &quot;Fiber 的基本概念&quot;">​</a></h2><h3 id="什么是-fiber" tabindex="-1">什么是 Fiber？ <a class="header-anchor" href="#什么是-fiber" aria-label="Permalink to &quot;什么是 Fiber？&quot;">​</a></h3><p>在 React 中，Fiber 有两层含义：</p><ol><li>作为架构，Fiber 是 React 16 中新的调和引擎或渲染架构。</li><li>作为数据结构，Fiber 是一个 JavaScript 对象，表示组件及其输入和输出的信息。</li></ol><p>每个 React 元素都对应一个 Fiber 节点，每个 Fiber 节点包含了组件的类型、状态、DOM 等信息。</p><h3 id="fiber-节点的结构" tabindex="-1">Fiber 节点的结构 <a class="header-anchor" href="#fiber-节点的结构" aria-label="Permalink to &quot;Fiber 节点的结构&quot;">​</a></h3><p>一个 Fiber 节点的典型结构如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 标记 Fiber 类型</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: WorkTag,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 唯一标识，通常是 key 属性</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 元素的类型，如 &#39;div&#39;, &#39;span&#39;, MyComponent 等</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  elementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 对于类组件，是类本身；对于函数组件，是函数本身；对于宿主组件，是字符串</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 与 Fiber 关联的本地状态，对于宿主组件是 DOM 节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  stateNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 指向父 Fiber</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Fiber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 指向第一个子 Fiber</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Fiber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 指向下一个兄弟 Fiber</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  sibling</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Fiber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 子元素在父元素中的索引</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 即将更新的 props</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  pendingProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 已经提交的 props</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  memoizedProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 更新队列</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  updateQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: UpdateQueue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">any</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 已经提交的状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  memoizedState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 依赖项，用于 Context 和 Hooks</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Dependencies </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 表示此 Fiber 需要进行的操作（如插入、更新、删除等）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  flags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Flags,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 子树的标记</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  subtreeFlags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Flags,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 需要删除的子节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  deletions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Fiber</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 指向另一个 Fiber，两者作为一对，一个代表当前状态，一个代表工作中的状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  alternate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Fiber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 性能分析相关</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  actualDuration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  actualStartTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  selfBaseDuration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  treeBaseDuration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="fiber-树与双缓冲" tabindex="-1">Fiber 树与双缓冲 <a class="header-anchor" href="#fiber-树与双缓冲" aria-label="Permalink to &quot;Fiber 树与双缓冲&quot;">​</a></h3><p>React 使用两棵 Fiber 树：</p><ol><li><strong>current 树</strong>：代表当前屏幕上显示的状态。</li><li><strong>workInProgress 树</strong>：代表正在构建的新状态。</li></ol><p>这种技术称为&quot;双缓冲&quot;，它允许 React 在后台准备新的 UI，而不影响当前显示的 UI。当 workInProgress 树准备好后，React 会通过一个简单的指针切换（称为&quot;提交阶段&quot;）使其成为新的 current 树。</p><h2 id="fiber-的工作流程" tabindex="-1">Fiber 的工作流程 <a class="header-anchor" href="#fiber-的工作流程" aria-label="Permalink to &quot;Fiber 的工作流程&quot;">​</a></h2><p>Fiber 的工作流程分为两个主要阶段：</p><h3 id="_1-render-reconciliation-阶段-可中断" tabindex="-1">1. Render/Reconciliation 阶段（可中断） <a class="header-anchor" href="#_1-render-reconciliation-阶段-可中断" aria-label="Permalink to &quot;1. Render/Reconciliation 阶段（可中断）&quot;">​</a></h3><p>这个阶段 React 会：</p><ul><li>更新状态和属性</li><li>调用生命周期方法</li><li>获取子元素</li><li>比较和协调先前的树与新树</li><li>确定需要进行的 DOM 更新</li></ul><p>这个阶段是可中断的，React 可以根据优先级暂停、继续或放弃工作。</p><h3 id="_2-commit-阶段-不可中断" tabindex="-1">2. Commit 阶段（不可中断） <a class="header-anchor" href="#_2-commit-阶段-不可中断" aria-label="Permalink to &quot;2. Commit 阶段（不可中断）&quot;">​</a></h3><p>这个阶段 React 会：</p><ul><li>执行所有副作用（如 DOM 更新）</li><li>调用相关的生命周期方法和 Hooks（如 <code>componentDidMount</code>, <code>useLayoutEffect</code> 等）</li></ul><p>这个阶段是不可中断的，必须一次性完成。</p><h2 id="fiber-的调度策略" tabindex="-1">Fiber 的调度策略 <a class="header-anchor" href="#fiber-的调度策略" aria-label="Permalink to &quot;Fiber 的调度策略&quot;">​</a></h2><p>React 使用 <code>requestIdleCallback</code> 和 <code>requestAnimationFrame</code> 的概念来调度工作。在浏览器空闲时执行低优先级工作，在动画帧中执行高优先级工作。</p><p>实际上，React 团队实现了自己的调度器（Scheduler），而不是直接使用 <code>requestIdleCallback</code>，因为后者在浏览器支持和性能方面存在一些限制。</p><h3 id="优先级模型" tabindex="-1">优先级模型 <a class="header-anchor" href="#优先级模型" aria-label="Permalink to &quot;优先级模型&quot;">​</a></h3><p>React 定义了几种不同的优先级级别：</p><ol><li><strong>Immediate</strong>：需要同步执行的任务</li><li><strong>UserBlocking</strong>：用户交互相关的任务，如输入、点击等</li><li><strong>Normal</strong>：不必立即显示的更新</li><li><strong>Low</strong>：可以延迟的任务</li><li><strong>Idle</strong>：可能永远不需要完成的任务</li></ol><h2 id="fiber-架构的优势" tabindex="-1">Fiber 架构的优势 <a class="header-anchor" href="#fiber-架构的优势" aria-label="Permalink to &quot;Fiber 架构的优势&quot;">​</a></h2><ol><li><strong>增强了应用的响应性</strong>：通过将工作分解为小单元并根据优先级调度，UI 更新不会阻塞用户交互。</li><li><strong>支持并发模式</strong>：允许 React 同时准备多个版本的 UI。</li><li><strong>更好的错误处理</strong>：可以更优雅地处理渲染错误。</li><li><strong>为新功能奠定基础</strong>：如 Suspense、并发模式等。</li></ol><h2 id="fiber-架构的挑战" tabindex="-1">Fiber 架构的挑战 <a class="header-anchor" href="#fiber-架构的挑战" aria-label="Permalink to &quot;Fiber 架构的挑战&quot;">​</a></h2><ol><li><strong>增加了实现的复杂性</strong>：Fiber 架构比栈调和器更复杂，理解和维护难度更高。</li><li><strong>可能导致不一致的行为</strong>：由于渲染可能被中断和恢复，某些生命周期方法可能被多次调用。</li><li><strong>调试难度增加</strong>：由于异步渲染，调试流程变得更加复杂。</li></ol><h2 id="实际应用中的考虑" tabindex="-1">实际应用中的考虑 <a class="header-anchor" href="#实际应用中的考虑" aria-label="Permalink to &quot;实际应用中的考虑&quot;">​</a></h2><p>在使用 React 时，了解 Fiber 架构可以帮助你：</p><ol><li><strong>避免使用不安全的生命周期方法</strong>：如 <code>componentWillMount</code>, <code>componentWillUpdate</code> 等，它们在 Fiber 架构下可能被多次调用。</li><li><strong>理解为什么需要 <code>key</code> 属性</strong>：Fiber 使用 key 来识别元素，提高调和效率。</li><li><strong>优化应用性能</strong>：了解 React 如何工作可以帮助你编写更高效的代码。</li><li><strong>使用新功能</strong>：如 Suspense、并发模式等，它们都是基于 Fiber 架构实现的。</li></ol><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Fiber 架构是 React 的一次重大重构，它通过将渲染工作分解为小单元并实现优先级调度，显著提高了 React 应用的响应性和性能。虽然 Fiber 增加了实现的复杂性，但它为 React 的未来发展奠定了坚实的基础，使得像 Suspense、并发模式等高级功能成为可能。</p><p>理解 Fiber 架构不仅有助于更好地使用 React，还能帮助你理解现代前端框架的工作原理和性能优化策略。</p>`,44)]))}const c=i(e,[["render",t]]);export{o as __pageData,c as default};

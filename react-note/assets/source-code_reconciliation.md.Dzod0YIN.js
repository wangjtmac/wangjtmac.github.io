import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.4lVnIIy3.js";const g=JSON.parse('{"title":"虚拟DOM与调和算法","description":"","frontmatter":{},"headers":[],"relativePath":"source-code/reconciliation.md","filePath":"source-code/reconciliation.md"}'),p={name:"source-code/reconciliation.md"};function h(t,s,k,e,E,r){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="虚拟dom与调和算法" tabindex="-1">虚拟DOM与调和算法 <a class="header-anchor" href="#虚拟dom与调和算法" aria-label="Permalink to &quot;虚拟DOM与调和算法&quot;">​</a></h1><h2 id="虚拟dom概念" tabindex="-1">虚拟DOM概念 <a class="header-anchor" href="#虚拟dom概念" aria-label="Permalink to &quot;虚拟DOM概念&quot;">​</a></h2><p>虚拟DOM（Virtual DOM）是React中的一个核心概念，它是真实DOM的一种轻量级表示。React使用虚拟DOM来提高性能和开发效率。</p><h3 id="什么是虚拟dom" tabindex="-1">什么是虚拟DOM？ <a class="header-anchor" href="#什么是虚拟dom" aria-label="Permalink to &quot;什么是虚拟DOM？&quot;">​</a></h3><p>虚拟DOM是一个普通的JavaScript对象，它描述了真实DOM的结构。每当组件的状态发生变化时，React会创建一个新的虚拟DOM树，然后将其与之前的虚拟DOM树进行比较，找出需要更新的部分，最后只更新实际DOM中需要变化的部分。</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 一个简单的React元素（虚拟DOM节点）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    className: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;container&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    children: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        props: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;标题&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        props: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;内容&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="虚拟dom的优势" tabindex="-1">虚拟DOM的优势 <a class="header-anchor" href="#虚拟dom的优势" aria-label="Permalink to &quot;虚拟DOM的优势&quot;">​</a></h3><ol><li><strong>性能优化</strong>：通过批量更新和最小化DOM操作，减少重排和重绘，提高渲染性能。</li><li><strong>跨平台能力</strong>：虚拟DOM是平台无关的，可以渲染到不同的环境（浏览器DOM、移动端原生视图、服务器端等）。</li><li><strong>开发体验</strong>：开发者可以使用声明式编程模型，而不必直接操作DOM。</li><li><strong>一致性</strong>：确保UI与应用状态保持一致。</li></ol><h2 id="调和过程-reconciliation" tabindex="-1">调和过程（Reconciliation） <a class="header-anchor" href="#调和过程-reconciliation" aria-label="Permalink to &quot;调和过程（Reconciliation）&quot;">​</a></h2><p>调和是React用来比较两棵虚拟DOM树并确定需要更新哪些部分的过程。</p><h3 id="调和算法" tabindex="-1">调和算法 <a class="header-anchor" href="#调和算法" aria-label="Permalink to &quot;调和算法&quot;">​</a></h3><p>React的调和算法（也称为Diffing算法）基于以下几个假设：</p><ol><li><strong>不同类型的元素会产生不同的树</strong>：如果根元素类型不同（如从<code>&lt;div&gt;</code>变为<code>&lt;span&gt;</code>），React会销毁旧树并创建新树。</li><li><strong>开发者可以通过key属性暗示哪些子元素在不同渲染中保持稳定</strong>：使用key可以帮助React识别列表中哪些项被添加、删除或重新排序。</li></ol><h3 id="diffing算法的步骤" tabindex="-1">Diffing算法的步骤 <a class="header-anchor" href="#diffing算法的步骤" aria-label="Permalink to &quot;Diffing算法的步骤&quot;">​</a></h3><ol><li><p><strong>比较根元素</strong>：</p><ul><li>如果类型不同，完全重建</li><li>如果类型相同，保留DOM节点，仅更新变化的属性</li></ul></li><li><p><strong>比较子元素</strong>：</p><ul><li>当比较两个相同类型的组件时，React会保留DOM节点，仅比较更新props</li><li>递归处理子节点</li></ul></li><li><p><strong>列表比较</strong>：</p><ul><li>没有key时，React会按顺序比较和更新</li><li>有key时，React可以识别元素的移动、添加和删除</li></ul></li></ol><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用key帮助React识别列表项</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TodoList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">todos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {todos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">todo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{todo.id}&gt;{todo.text}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ))}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="fiber架构" tabindex="-1">Fiber架构 <a class="header-anchor" href="#fiber架构" aria-label="Permalink to &quot;Fiber架构&quot;">​</a></h2><p>在React 16中，React引入了Fiber架构，这是对调和算法的重写，旨在解决大型应用中的性能问题。</p><h3 id="fiber的目标" tabindex="-1">Fiber的目标 <a class="header-anchor" href="#fiber的目标" aria-label="Permalink to &quot;Fiber的目标&quot;">​</a></h3><ol><li><strong>能够暂停、中止或重用工作</strong>：将渲染工作分解为小单元，可以根据优先级安排任务。</li><li><strong>为不同类型的更新分配优先级</strong>：如动画更新优先级高于数据更新。</li><li><strong>支持并发模式</strong>：允许React在后台准备新的UI而不阻塞主线程。</li></ol><h3 id="fiber节点" tabindex="-1">Fiber节点 <a class="header-anchor" href="#fiber节点" aria-label="Permalink to &quot;Fiber节点&quot;">​</a></h3><p>Fiber节点是虚拟DOM节点的内部表示，包含了更多信息：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 标记节点类型</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: WorkTag,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 唯一标识</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 元素类型</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  elementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 函数/类组件本身</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 对应的DOM节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  stateNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 指向父、子、兄弟节点的指针，形成链表结构</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Fiber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Fiber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  sibling</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Fiber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 索引</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 组件的props</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  pendingProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  memoizedProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 更新队列</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  updateQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: UpdateQueue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">any</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 组件的state</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  memoizedState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 依赖</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Dependencies </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 标记此节点需要进行的操作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  flags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Flags,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 子树标记</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  subtreeFlags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Flags,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 删除标记</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  deletions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Fiber</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 替代节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  alternate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Fiber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 调试信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  actualDuration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  actualStartTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  selfBaseDuration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  treeBaseDuration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="工作循环" tabindex="-1">工作循环 <a class="header-anchor" href="#工作循环" aria-label="Permalink to &quot;工作循环&quot;">​</a></h3><p>Fiber架构引入了两个阶段的工作循环：</p><ol><li><p><strong>Render/Reconciliation阶段</strong>（可中断）：</p><ul><li>构建Fiber树</li><li>执行Diff算法</li><li>收集副作用（如需要插入、更新或删除的节点）</li></ul></li><li><p><strong>Commit阶段</strong>（不可中断）：</p><ul><li>执行收集到的副作用</li><li>更新DOM</li><li>调用生命周期方法和Hooks</li></ul></li></ol><h2 id="性能优化建议" tabindex="-1">性能优化建议 <a class="header-anchor" href="#性能优化建议" aria-label="Permalink to &quot;性能优化建议&quot;">​</a></h2><p>基于对虚拟DOM和调和过程的理解，以下是一些性能优化建议：</p><ol><li><strong>使用合适的key</strong>：在列表中使用稳定、唯一的key，避免使用索引作为key。</li><li><strong>避免不必要的渲染</strong>：使用<code>React.memo</code>、<code>useMemo</code>和<code>useCallback</code>来避免不必要的重新渲染。</li><li><strong>保持组件纯净</strong>：确保组件是纯函数，相同的props和state总是产生相同的输出。</li><li><strong>拆分大型组件</strong>：将大型组件拆分为更小的组件，以便React可以更精确地更新。</li><li><strong>使用生产模式</strong>：在生产环境中使用压缩版本的React。</li></ol><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>虚拟DOM和调和算法是React高效更新UI的核心机制。通过理解这些概念，开发者可以编写更高效的React应用，并在遇到性能问题时有针对性地进行优化。</p><p>React的Fiber架构进一步提升了性能，特别是在大型应用中，通过可中断的渲染过程和优先级调度，提供了更流畅的用户体验。</p>`,32)]))}const o=i(p,[["render",h]]);export{g as __pageData,o as default};
